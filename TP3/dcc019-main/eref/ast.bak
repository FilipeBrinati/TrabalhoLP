#lang racket

(provide (prefix-out ast: (all-defined-out)))

#| The AST of EREF language

Exp ::= INT | VAR
     |  ZERO? Exp | DIF Exp Exp
     |  IF Exp Exp Exp | LET VAR Exp Exp
     | PROC VAR Exp | CALL Expr Exp
     | LETREC VAR VAR Exp Exp
     | BEGIN Exp {Exp}
     | NEWREF Exp | FREEREF Exp
     | DEREF Exp | SETREF Exp Exp


or, in a list notation

Exp ::= INT | VAR
     |  (ZERO? Exp) | (DIF Exp Exp)
     |  (IF Exp Exp Exp) | (LET VAR Exp Exp)
     |  (PROC VAR Exp)   | (CALL Exp Exp)
     |  (LETREC VAR VAR Exp Exp)
     |  (BEGIN Exp Exp ... )
     |  (NEWREF Exp) | (FREEREF Exp)
     |  (DEREF Exp) | (SETREF Exp Exp)

|#

;; leaves

; INT
(struct int (value) #:transparent)

; BOOL, although we don't have the concrete syntax for boolean literals
(struct bool (value) #:transparent)

; VAR
(struct var (name) #:transparent)

;; internal nodes

; ZERO? Exp
(struct zero? (exp) #:transparent)

; DIF Exp Exp
(struct dif (rexp lexp) #:transparent)
  
; IF Exp Exp Exp
(struct if (guard-exp then-exp else-exp) #:transparent)

; LET VAR Exp Exp
(struct let (var iexp vexp) #:transparent)

; PROC VAR Exp
(struct proc (var body) #:transparent)

; CALL Exp Exp
(struct call (lexp rexp) #:transparent)

; LETREC VAR VAR Exp Exp
(struct letrec (name var body exp) #:transparent)

; BEGIN Exp {Exp}
(struct begin (exps) #:transparent)

; NEWREF Exp
(struct newref (addr) #:transparent)

; FREEREF Exp
(struct freeref (addr) #:transparent)

; DEREF Exp
(struct deref (addr) #:transparent)

; SETREF Exp Exp
(struct setref (addr value) #:transparent)

;; eval-exp function

(define (eval-exp exp env)
  (match exp
    [(int value) value]
    [(var name) (lookup name env)]
    [(zero? exp) (zero? (eval-exp exp env))]
    [(dif rexp lexp)
     (- (eval-exp rexp env) (eval-exp lexp env))] ; Avalia a expressão da direita antes da expressão da esquerda
    [(if guard-exp then-exp else-exp)
     (if (eval-exp guard-exp env)
         (eval-exp then-exp env)
         (eval-exp else-exp env))]
    [(let var iexp vexp)
     (let ([ival (eval-exp iexp env)])
       (eval-exp vexp (extend env var ival)))]
    [(proc var body) (proc-closure var body env)]
    [(call lexp rexp)
     (apply-procedure (eval-exp lexp env) (eval-exp rexp env))]
    [(letrec name var body exp)
     (letrec ([closure (proc-closure var body env)])
       (eval-exp exp (extend env name closure)))]
    [(begin . exps)
     (for-each (lambda (exp) (void (eval-exp exp env))) exps)
     (eval-exp (last exps) env)]
    [(newref addr) (make-ref (eval-exp addr env))]
    [(freeref addr) (void (eval-exp addr env))]
    [(deref addr) (ref-value (eval-exp addr env))]
    [(setref addr value) (set-ref-value! (eval-exp addr env) (eval-exp value env))]))
